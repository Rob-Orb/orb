--- a/orb_motor_completion.bash
+++ b/orb_motor_completion.bash
@@ -1,2 +1,19 @@
 #/usr/bin/env bash
-complete -W "motor" upload
+_orb_motor_completion()
+{
+	local cur prev
+
+	#COMPREPLY=()
+	cur="${COMP_WORDS[COMP_CWORD]}"
+	prev="${COMP_WORDS[COMP_CWORD-1]}"
+
+	if [ $COMP_CWORD == 2 ]; then
+		case "$prev" in
+			"motor")
+			COMPREPLY=($(compgen -W "-d -m -r" -- $cur));;
+		*)
+		;;
+		esac
+	fi
+	return 0
+}
--- a/src/orb.cpp
+++ b/src/orb.cpp
@@ -16,7 +16,8 @@
 	"Options:" << endl <<
 	"-h\tprint help" << endl <<
 	"-m\tmotor (0:all - default, 1-2)" <<endl <<
-	"-d\tduty cycle (0-100)%" << endl << endl;
+	"-d\tduty cycle (0-100)%" << endl << 
+	"-r\tread encoder (1,2)" << endl << endl;
 }
 
 int main(int argc, char *argv[])
@@ -26,15 +27,17 @@
 	
 	int du = 10000;
 	int mo = 0;
+	int re = 10;
 	bool h = false;
 	
 	static struct option long_options[] = {
 		{"help",	no_argument, 0,	'h'},
 		{"motor",	required_argument, 0,	'm'},
 		{"duty",	required_argument, 0,	'd'},
+		{"read",	required_argument, 0,	'r'},
 		{0,0,0,0}
 	};
-	while ((opt = getopt_long(argc, argv, "hm:d:",long_options, &option_index)) != -1) {
+	while ((opt = getopt_long(argc, argv, "hm:d:r:",long_options, &option_index)) != -1) {
 		switch (opt) {
 			case 'm':
 				mo = atoi(optarg);
@@ -50,6 +53,13 @@
                                         return 0;
                                 }
 				break;
+			case 'r':
+				re = atoi(optarg);
+				if(optarg[0] == '-' || re > 2){
+					cerr << "Wrong input to option r" << endl;
+					return 0;
+				}
+				break;
 			case 'h':
 			default:
 				h = true;
@@ -69,5 +79,9 @@
 		wiringPiI2CWriteReg8(fd, 0x02, mo);
 	if(du < 101)
 		wiringPiI2CWriteReg8(fd, 0x01, uint8_t(du*2.55));
+	if(re < 10){
+		wiringPiI2CWriteReg8(fd, 0x03, re);
+		cout << wiringPiI2CRead(fd) << endl;
+	}
 	return 0;
 }
